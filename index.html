<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="apple-mobile-web-app-title" content="bookshelf" />
  <meta name="theme-color" content="#F7F5F0" />
  <title>bookshelf</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;1,300;1,400&family=Karla:wght@300;400;500&family=IBM+Plex+Mono:wght@300;400&display=swap" rel="stylesheet" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body, #root { height: 100%; }
    body { background: #F7F5F0; font-family: 'Karla', sans-serif; -webkit-font-smoothing: antialiased; color: #1A1917; }
    ::selection { background: #8C857A; color: #fff; }
    input::placeholder { color: #A09B93; }
    textarea::placeholder { color: #A09B93; }
    input:focus, select:focus, textarea:focus { outline: none; border-color: #A09B93 !important; }
    @keyframes slideUp {
      from { opacity: 0; transform: translateY(12px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // ‚îÄ‚îÄ IndexedDB Storage Helper ‚îÄ‚îÄ
    const DB_NAME = "bookshelf-db";
    const STORE_NAME = "data";
    const openDB = () => new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = () => req.result.createObjectStore(STORE_NAME);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
    const dbGet = async (key) => {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, "readonly");
        const req = tx.objectStore(STORE_NAME).get(key);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    };
    const dbSet = async (key, value) => {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, "readwrite");
        tx.objectStore(STORE_NAME).put(value, key);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    };

    // ‚îÄ‚îÄ Gist Sync ‚îÄ‚îÄ
    const GIST_TOKEN_KEY = "shelf-gist-token";
    const GIST_ID_KEY = "shelf-gist-id";
    const GIST_FILENAME = "bookshelf-data.json";

    const getGistConfig = () => ({
      token: localStorage.getItem(GIST_TOKEN_KEY),
      gistId: localStorage.getItem(GIST_ID_KEY),
    });

    const saveGistConfig = (token, gistId) => {
      localStorage.setItem(GIST_TOKEN_KEY, token);
      localStorage.setItem(GIST_ID_KEY, gistId);
    };

    const clearGistConfig = () => {
      localStorage.removeItem(GIST_TOKEN_KEY);
      localStorage.removeItem(GIST_ID_KEY);
    };

    const gistFetch = async () => {
      const { token, gistId } = getGistConfig();
      if (!token || !gistId) return null;
      try {
        const res = await fetch(`https://api.github.com/gists/${gistId}`, {
          headers: { Authorization: `token ${token}`, Accept: "application/vnd.github.v3+json" },
        });
        if (!res.ok) return null;
        const gist = await res.json();
        const file = gist.files[GIST_FILENAME];
        if (!file) return null;
        return JSON.parse(file.content);
      } catch (e) { console.error("Gist fetch failed:", e); return null; }
    };

    const gistPush = async (data) => {
      const { token, gistId } = getGistConfig();
      if (!token || !gistId) return false;
      try {
        const res = await fetch(`https://api.github.com/gists/${gistId}`, {
          method: "PATCH",
          headers: { Authorization: `token ${token}`, Accept: "application/vnd.github.v3+json", "Content-Type": "application/json" },
          body: JSON.stringify({ files: { [GIST_FILENAME]: { content: JSON.stringify(data, null, 2) } } }),
        });
        return res.ok;
      } catch (e) { console.error("Gist push failed:", e); return false; }
    };

    const gistCreate = async (token) => {
      try {
        const res = await fetch("https://api.github.com/gists", {
          method: "POST",
          headers: { Authorization: `token ${token}`, Accept: "application/vnd.github.v3+json", "Content-Type": "application/json" },
          body: JSON.stringify({
            description: "bookshelf sync data",
            public: false,
            files: { [GIST_FILENAME]: { content: JSON.stringify({ reading: [], want: [], finished: [] }, null, 2) } },
          }),
        });
        if (!res.ok) return null;
        const gist = await res.json();
        return gist.id;
      } catch (e) { console.error("Gist create failed:", e); return null; }
    };

    // ‚îÄ‚îÄ Constants ‚îÄ‚îÄ
    const FORMATS = ["Audiobook", "Ebook", "Physical"];
    const PLATFORMS = { Audiobook: ["Libby", "Audible", "Spotify"], Ebook: ["Kindle", "Libby"], Physical: ["Owned", "Loaned"] };
    const TABS = [
      { id: "reading", label: "Currently Reading", icon: "" },
      { id: "want", label: "Want to Read", icon: "" },
      { id: "finished", label: "Finished", icon: "" },
    ];
    const FORMAT_ICONS = { Audiobook: "", Ebook: "", Physical: "" };
    const PLATFORM_COLORS = { Kindle: "#D97706", Libby: "#DC2626", Audible: "#F59E0B", Spotify: "#16A34A", Owned: "#8B7355", Loaned: "#6B7280" };
    const GENRES = ["Thriller", "Romance", "Sci-Fi", "Fantasy", "Mystery", "Horror", "Literary Fiction", "Historical Fiction", "Non-Fiction", "Self-Help", "Memoir", "Biography", "True Crime"];
    const initialBooks = { reading: [], want: [], finished: [] };

    function BookTracker() {
      const [tab, setTab] = useState("reading");
      const [books, setBooks] = useState(initialBooks);
      const [booksLoaded, setBooksLoaded] = useState(false);
      const [showAdd, setShowAdd] = useState(false);
      const [search, setSearch] = useState("");
      const [title, setTitle] = useState("");
      const [author, setAuthor] = useState("");
      const [coverUrl, setCoverUrl] = useState("");
      const [format, setFormat] = useState("Ebook");
      const [platform, setPlatform] = useState("Kindle");
      const [progress, setProgress] = useState("");
      const [dateStarted, setDateStarted] = useState(() => new Date().toISOString().slice(0, 10));
      const [editingId, setEditingId] = useState(null);
      const [confirmDelete, setConfirmDelete] = useState(null);
      const [showBulk, setShowBulk] = useState(false);
      const [sortBy, setSortBy] = useState("date-desc");
      const [groupBy, setGroupBy] = useState("none");
      const [bulkText, setBulkText] = useState("");
      const [bulkFormat, setBulkFormat] = useState("Ebook");
      const [bulkPlatform, setBulkPlatform] = useState("Kindle");
      const [bulkTab, setBulkTab] = useState("reading");
      const [bulkPreview, setBulkPreview] = useState([]);
      const [swipeStates, setSwipeStates] = useState({});
      const [toast, setToast] = useState(null);
      const [urlParsed, setUrlParsed] = useState(null);
      const [tags, setTags] = useState([]);
      const [synopsis, setSynopsis] = useState("");
      const [expandedSynopsis, setExpandedSynopsis] = useState(null);
      const [customTagInput, setCustomTagInput] = useState("");
      const [customTags, setCustomTags] = useState([]);
      const [showSyncSetup, setShowSyncSetup] = useState(false);
      const [showSettings, setShowSettings] = useState(false);
      const [syncStatus, setSyncStatus] = useState("idle"); // idle, syncing, synced, error
      const [syncConnected, setSyncConnected] = useState(() => {
        const { token, gistId } = getGistConfig();
        return !!(token && gistId);
      });
      const [syncTokenInput, setSyncTokenInput] = useState("");
      const [syncGistIdInput, setSyncGistIdInput] = useState("");
      const [syncStep, setSyncStep] = useState(() => {
        const { token, gistId } = getGistConfig();
        return (token && gistId) ? "connected" : "start";
      });
      const [syncError, setSyncError] = useState("");
      const [syncWorking, setSyncWorking] = useState(false);
      const touchRef = useRef({});
      const inputRef = useRef(null);
      const bulkRef = useRef(null);
      const syncDebounce = useRef(null);

      // Migrate old format/platform values
      const migrateBook = (b) => {
        let book = { ...b };
        if (book.format === "Kindle") { book.format = "Ebook"; book.platform = book.platform || "Kindle"; }
        if (book.platform === "IRL") { book.platform = "Owned"; }
        return book;
      };
      const migrateBooks = (data) => ({
        reading: data.reading.map(migrateBook),
        want: data.want.map(migrateBook),
        finished: data.finished.map(migrateBook),
      });

      // Load from IndexedDB first, then overlay Gist data
      useEffect(() => {
        (async () => {
          try {
            const data = await dbGet("shelf-books");
            if (data && data.reading && data.want && data.finished) setBooks(migrateBooks(data));
          } catch (e) {}
          try {
            const ct = await dbGet("shelf-custom-tags");
            if (ct && Array.isArray(ct)) setCustomTags(ct);
          } catch (e) {}
          // Try loading from Gist
          const { token, gistId } = getGistConfig();
          if (token && gistId) {
            setSyncStatus("syncing");
            const gistData = await gistFetch();
            if (gistData) {
              if (gistData.books && gistData.books.reading && gistData.books.want && gistData.books.finished) {
                setBooks(migrateBooks(gistData.books));
              }
              if (gistData.customTags && Array.isArray(gistData.customTags)) {
                setCustomTags(gistData.customTags);
              }
              setSyncStatus("synced");
            } else {
              setSyncStatus("error");
            }
          }
          setBooksLoaded(true);
        })();
      }, []);

      // Save to IndexedDB + Gist
      useEffect(() => {
        if (!booksLoaded) return;
        dbSet("shelf-books", books).catch(e => console.error("Save failed:", e));
        dbSet("shelf-custom-tags", customTags).catch(e => console.error("Save tags failed:", e));
        // Debounced Gist push
        if (syncConnected) {
          if (syncDebounce.current) clearTimeout(syncDebounce.current);
          syncDebounce.current = setTimeout(async () => {
            setSyncStatus("syncing");
            const ok = await gistPush({ books, customTags, lastUpdated: new Date().toISOString() });
            setSyncStatus(ok ? "synced" : "error");
          }, 1500);
        }
      }, [books, customTags, booksLoaded]);

      useEffect(() => { if (showAdd && inputRef.current) inputRef.current.focus(); }, [showAdd]);
      useEffect(() => { if (showBulk && bulkRef.current) bulkRef.current.focus(); }, [showBulk]);
      useEffect(() => { setPlatform(PLATFORMS[format][0]); }, [format]);
      useEffect(() => { setBulkPlatform(PLATFORMS[bulkFormat][0]); }, [bulkFormat]);
      useEffect(() => { if (toast) { const t = setTimeout(() => setToast(null), 2500); return () => clearTimeout(t); } }, [toast]);

      // URL detection
      useEffect(() => {
        const s = search.trim();
        if (!s) { setUrlParsed(null); return; }
        const amazonMatch = s.match(/amazon\.com.*?\/dp\/[A-Z0-9]+/i) || s.match(/amazon\.com.*?\/([^\/\?]+)/i);
        const goodreadsMatch = s.match(/goodreads\.com\/book\/show\/[\d]+-?([\w-]+)?/i);
        if (amazonMatch || goodreadsMatch) {
          let extracted = "";
          if (goodreadsMatch && goodreadsMatch[1]) {
            extracted = goodreadsMatch[1].replace(/[-_]/g, " ").replace(/\b\w/g, c => c.toUpperCase());
          } else if (amazonMatch) {
            const pathMatch = s.match(/\/([^\/]+)\/dp\//);
            if (pathMatch) extracted = decodeURIComponent(pathMatch[1]).replace(/[-_+]/g, " ").replace(/\b\w/g, c => c.toUpperCase());
          }
          setUrlParsed(extracted || "Book from link");
        } else { setUrlParsed(null); }
      }, [search]);

      // Swipe handlers
      const handleTouchStart = (id, e) => { touchRef.current[id] = { startX: e.touches[0].clientX, startY: e.touches[0].clientY }; };
      const handleTouchMove = (id, e) => {
        if (!touchRef.current[id]) return;
        const dx = e.touches[0].clientX - touchRef.current[id].startX;
        const dy = Math.abs(e.touches[0].clientY - touchRef.current[id].startY);
        if (dy > 30) { touchRef.current[id] = null; setSwipeStates(p => ({...p, [id]: 0})); return; }
        if (dx < 0) setSwipeStates(p => ({...p, [id]: Math.min(Math.abs(dx), 120)}));
      };
      const handleTouchEnd = (id, book) => {
        if ((swipeStates[id] || 0) > 70) quickSaveToWant(book.title, book.author || "");
        touchRef.current[id] = null;
        setSwipeStates(p => ({...p, [id]: 0}));
      };
      const handleMouseDown = (id, e) => { touchRef.current[id] = { startX: e.clientX, mouseDown: true }; };
      const handleMouseMove = (id, e) => {
        if (!touchRef.current[id]?.mouseDown) return;
        const dx = e.clientX - touchRef.current[id].startX;
        if (dx < 0) setSwipeStates(p => ({...p, [id]: Math.min(Math.abs(dx), 120)}));
      };
      const handleMouseUp = (id, book) => {
        if ((swipeStates[id] || 0) > 70) quickSaveToWant(book.title, book.author || "");
        if (touchRef.current[id]) touchRef.current[id].mouseDown = false;
        setSwipeStates(p => ({...p, [id]: 0}));
      };

      const quickSaveToWant = (bookTitle, bookAuthor) => {
        if (!bookTitle.trim()) return;
        const allBooks = [...books.reading, ...books.want, ...books.finished];
        if (allBooks.some(b => b.title.toLowerCase() === bookTitle.trim().toLowerCase())) {
          setToast({ text: `"${bookTitle}" is already in your library`, type: "info" }); return;
        }
        const newBook = {
          id: Date.now(), title: bookTitle.trim(), author: bookAuthor.trim(),
          format: "", platform: "", progress: "", tags: [],
          dateStarted: new Date().toISOString().slice(0, 10),
          addedAt: new Date().toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" }),
        };
        setBooks(prev => ({ ...prev, want: [...prev.want, newBook] }));
        setToast({ text: `"${bookTitle}" saved to Want to Read`, type: "success" });
        setSearch(""); setUrlParsed(null);
      };

      const addBook = () => {
        if (!title.trim()) return;
        const newBook = {
          id: Date.now(), title: title.trim(), author: author.trim(),
          format: tab === "want" ? "" : format, platform: tab === "want" ? "" : platform, progress: progress.trim(), dateStarted, tags: [...tags],
          coverUrl: coverUrl.trim(), synopsis: synopsis.trim(),
          addedAt: new Date().toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" }),
        };
        if (editingId) {
          setBooks(prev => {
            const updated = {};
            for (const key in prev) updated[key] = prev[key].map(b => b.id === editingId ? { ...newBook, id: editingId, addedAt: b.addedAt } : b);
            return updated;
          });
          setEditingId(null);
        } else {
          setBooks(prev => ({ ...prev, [tab]: [...prev[tab], newBook] }));
        }
        resetForm();
      };

      const resetForm = () => {
        setTitle(""); setAuthor(""); setCoverUrl(""); setFormat("Ebook"); setPlatform("Kindle");
        setProgress(""); setDateStarted(new Date().toISOString().slice(0, 10));
        setTags([]); setCustomTagInput(""); setSynopsis("");
        setShowAdd(false); setEditingId(null);
      };

      const parseBulkText = (text) => {
        const lines = text.split("\n").map(l => l.replace(/^\*\s*/, "").trim()).filter(l => l);
        const isJunk = (line) => {
          const l = line.trim().toLowerCase();
          if (!l) return true;
          if (/^\d+$/.test(l)) return true;
          if (/^in\s*\d*$/i.test(l)) return true;
          if (/^(device|read|sample|loan|subscription|downloaded|delete|more actions|update available)$/i.test(l)) return true;
          if (/^deliver or remove/i.test(l)) return true;
          if (/^return this/i.test(l)) return true;
          if (/^add to collection/i.test(l)) return true;
          if (l.length <= 2 && !/[a-z]{2}/i.test(l)) return true;
          return false;
        };
        const cleaned = lines.filter(l => !isJunk(l));
        const hasKindleFormat = cleaned.some(l => /^Acquired on\s/i.test(l));

        if (hasKindleFormat) {
          const result = [];
          let i = 0;
          while (i < cleaned.length) {
            const line = cleaned[i];
            if (/^Acquired on\s/i.test(line)) { i++; continue; }
            const titleLine = line;
            let auth = "", ds = "";
            if (i + 1 < cleaned.length) {
              if (/^Acquired on\s/i.test(cleaned[i + 1])) {
                const dm = cleaned[i + 1].match(/Acquired on\s+(.+)/i);
                if (dm) { const p = new Date(dm[1]); if (!isNaN(p)) ds = p.toISOString().slice(0, 10); }
                i += 2;
              } else {
                auth = cleaned[i + 1];
                if (i + 2 < cleaned.length && /^Acquired on\s/i.test(cleaned[i + 2])) {
                  const dm = cleaned[i + 2].match(/Acquired on\s+(.+)/i);
                  if (dm) { const p = new Date(dm[1]); if (!isNaN(p)) ds = p.toISOString().slice(0, 10); }
                  i += 3;
                } else { i += 2; }
              }
            } else { i++; }
            let t = titleLine.replace(/^["'\u201c\u201d]|["'\u201c\u201d]$/g, "").trim();
            auth = auth.replace(/^["'\u201c\u201d]|["'\u201c\u201d]$/g, "").trim();
            if (t) result.push({ title: t, author: auth, dateStarted: ds || new Date().toISOString().slice(0, 10) });
          }
          return result;
        }

        return cleaned.map(line => {
          const trimmed = line.replace(/^[\d.\-\u2022*)\]\s]+/, "").trim();
          let t = trimmed, a = "";
          const byM = trimmed.match(/^(.+?)\s+by\s+(.+)$/i);
          const dashM = trimmed.match(/^(.+?)\s+[-\u2013\u2014]\s+(.+)$/);
          const commaM = trimmed.match(/^(.+?),\s+(.+)$/);
          if (byM) { t = byM[1].trim(); a = byM[2].trim(); }
          else if (dashM) { t = dashM[1].trim(); a = dashM[2].trim(); }
          else if (commaM) { t = commaM[1].trim(); a = commaM[2].trim(); }
          t = t.replace(/^["'\u201c\u201d]|["'\u201c\u201d]$/g, "").trim();
          a = a.replace(/^["'\u201c\u201d]|["'\u201c\u201d]$/g, "").trim();
          return { title: t, author: a, dateStarted: new Date().toISOString().slice(0, 10) };
        });
      };

      useEffect(() => { setBulkPreview(bulkText.trim() ? parseBulkText(bulkText) : []); }, [bulkText]);

      const submitBulk = () => {
        if (bulkPreview.length === 0) return;
        const now = new Date().toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" });
        const newBooks = bulkPreview.map((b, i) => ({
          id: Date.now() + i, title: b.title, author: b.author,
          format: bulkTab === "want" ? "" : bulkFormat, platform: bulkTab === "want" ? "" : bulkPlatform, progress: "",
          tags: [],
          dateStarted: b.dateStarted || new Date().toISOString().slice(0, 10), addedAt: now,
        }));
        setBooks(prev => ({ ...prev, [bulkTab]: [...prev[bulkTab], ...newBooks] }));
        setTab(bulkTab); setBulkText(""); setBulkPreview([]); setShowBulk(false);
      };

      // Export library as JSON file
      const exportLibrary = () => {
        const data = JSON.stringify(books, null, 2);
        const blob = new Blob([data], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `bookshelf-backup-${new Date().toISOString().slice(0, 10)}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        setToast({ text: "Library exported successfully", type: "success" });
      };

      // Import library from JSON file
      const importLibrary = () => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".json";
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (ev) => {
            try {
              const parsed = JSON.parse(ev.target.result);
              if (parsed.reading && parsed.want && parsed.finished) {
                setBooks(parsed);
                setToast({ text: `Imported ${parsed.reading.length + parsed.want.length + parsed.finished.length} books`, type: "success" });
              } else {
                setToast({ text: "Invalid backup file", type: "info" });
              }
            } catch (err) {
              setToast({ text: "Could not read file", type: "info" });
            }
          };
          reader.readAsText(file);
        };
        input.click();
      };

      // Import synopses from JSON file {title: synopsis}
      const importSynopses = () => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".json";
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (ev) => {
            try {
              const synopses = JSON.parse(ev.target.result);
              let matched = 0;
              setBooks(prev => {
                const updated = {};
                for (const key in prev) {
                  updated[key] = prev[key].map(b => {
                    const match = Object.keys(synopses).find(t => t.toLowerCase() === b.title.toLowerCase());
                    if (match && synopses[match]) { matched++; return { ...b, synopsis: synopses[match] }; }
                    return b;
                  });
                }
                setTimeout(() => setToast({ text: `Matched synopses for ${matched} books`, type: "success" }), 100);
                return updated;
              });
            } catch (err) {
              setToast({ text: "Could not read synopses file", type: "info" });
            }
          };
          reader.readAsText(file);
        };
        input.click();
      };

      // Import tags from JSON file {title: ["tag1", "tag2"]}
      const importTags = () => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".json";
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (ev) => {
            try {
              const tagMap = JSON.parse(ev.target.result);
              let matched = 0;
              const newCustom = new Set(customTags);
              setBooks(prev => {
                const updated = {};
                for (const key in prev) {
                  updated[key] = prev[key].map(b => {
                    const match = Object.keys(tagMap).find(t => t.toLowerCase() === b.title.toLowerCase());
                    if (match && Array.isArray(tagMap[match])) {
                      matched++;
                      tagMap[match].forEach(t => { if (!GENRES.includes(t)) newCustom.add(t); });
                      return { ...b, tags: tagMap[match] };
                    }
                    return b;
                  });
                }
                setTimeout(() => setToast({ text: `Tagged ${matched} books`, type: "success" }), 100);
                return updated;
              });
              setCustomTags([...newCustom]);
            } catch (err) {
              setToast({ text: "Could not read tags file", type: "info" });
            }
          };
          reader.readAsText(file);
        };
        input.click();
      };

      const moveBook = (bookId, fromTab, toTab) => {
        const book = books[fromTab].find(b => b.id === bookId);
        if (!book) return;
        setBooks(prev => ({
          ...prev,
          [fromTab]: prev[fromTab].filter(b => b.id !== bookId),
          [toTab]: [...prev[toTab], { ...book, movedAt: new Date().toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" }) }],
        }));
      };

      const deleteBook = (bookId, fromTab) => {
        setBooks(prev => ({ ...prev, [fromTab]: prev[fromTab].filter(b => b.id !== bookId) }));
        setConfirmDelete(null);
      };

      const editBook = (book) => {
        setTitle(book.title); setAuthor(book.author); setCoverUrl(book.coverUrl || ""); setFormat(book.format || "Ebook");
        setPlatform(book.platform || "Kindle"); setProgress(book.progress || "");
        setDateStarted(book.dateStarted || new Date().toISOString().slice(0, 10));
        setTags(book.tags || []);
        setSynopsis(book.synopsis || "");
        setEditingId(book.id); setShowAdd(true);
      };

      const allBooks = [...books.reading, ...books.want, ...books.finished];
      const searchResults = search.trim()
        ? allBooks.filter(b => b.title.toLowerCase().includes(search.toLowerCase()) || b.author.toLowerCase().includes(search.toLowerCase()))
        : [];

      const getBookStatus = (book) => {
        if (books.reading.find(b => b.id === book.id)) return "Currently Reading";
        if (books.want.find(b => b.id === book.id)) return "Want to Read";
        if (books.finished.find(b => b.id === book.id)) return "Finished";
        return "";
      };

      const filteredBooks = books[tab].filter(b =>
        !search.trim() || b.title.toLowerCase().includes(search.toLowerCase()) || b.author.toLowerCase().includes(search.toLowerCase())
      );

      const sortedBooks = [...filteredBooks].sort((a, b) => {
        switch (sortBy) {
          case "title-asc": return a.title.localeCompare(b.title);
          case "title-desc": return b.title.localeCompare(a.title);
          case "author-asc": return (a.author || "").localeCompare(b.author || "");
          case "author-desc": return (b.author || "").localeCompare(a.author || "");
          case "date-asc": return (a.dateStarted || "").localeCompare(b.dateStarted || "");
          case "date-desc": return (b.dateStarted || "").localeCompare(a.dateStarted || "");
          default: return 0;
        }
      });

      const groupedBooks = (() => {
        if (groupBy === "none") return null;
        const groups = {};
        sortedBooks.forEach(book => {
          if (groupBy === "tag") {
            const bookTags = book.tags && book.tags.length > 0 ? book.tags : ["Untagged"];
            bookTags.forEach(t => {
              if (!groups[t]) groups[t] = [];
              groups[t].push(book);
            });
          } else {
            const key = groupBy === "author" ? (book.author || "Unknown Author") : (book.format || "Unknown");
            if (!groups[key]) groups[key] = [];
            groups[key].push(book);
          }
        });
        return Object.entries(groups).sort((a, b) => a[0].localeCompare(b[0]));
      })();

      const renderBookCard = (book) => (
        React.createElement(React.Fragment, null,
          React.createElement("div", { style: S.bookTop },
            book.coverUrl && React.createElement("img", { src: book.coverUrl, style: S.coverImg, alt: book.title, onError: (e) => { e.target.style.display = "none"; } }),
            React.createElement("div", { style: S.bookInfo },
              React.createElement("div", { style: S.bookTitle }, book.title),
              React.createElement("div", { style: S.authorRow },
                book.author && React.createElement("span", { style: S.bookAuthor }, book.author),
                (book.format || book.platform) && React.createElement("span", { style: { ...S.platformTagInline, background: (PLATFORM_COLORS[book.platform] || "#A8A29E") + "15", color: PLATFORM_COLORS[book.platform] || "#A8A29E", borderColor: (PLATFORM_COLORS[book.platform] || "#A8A29E") + "30" } }, [book.format, book.platform].filter(Boolean).join(" ¬∑ "))
              ),
              (book.tags && book.tags.length > 0 || book.dateStarted) && React.createElement("div", { style: S.bookMeta },
                book.tags && book.tags.length > 0 && book.tags.map(t => React.createElement("span", { key: t, style: S.genreTag }, t)),
                book.dateStarted && React.createElement("span", { style: S.dateTag },
                  (tab === "want" ? "Saved " : "Started ") + new Date(book.dateStarted + "T00:00:00").toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" })
                )
              )
            ),
            React.createElement("div", { style: S.bookActions },
              React.createElement("button", { style: S.iconBtn, onClick: () => editBook(book), title: "Edit" }, "‚úé"),
              confirmDelete === book.id
                ? React.createElement("span", { style: S.confirmRow },
                    React.createElement("button", { style: { ...S.iconBtn, color: "#DC2626" }, onClick: () => deleteBook(book.id, tab) }, "Yes"),
                    React.createElement("button", { style: S.iconBtn, onClick: () => setConfirmDelete(null) }, "No")
                  )
                : React.createElement("button", { style: { ...S.iconBtn, color: "#A8A29E" }, onClick: () => setConfirmDelete(book.id), title: "Delete" }, "√ó")
            )
          ),
          book.synopsis && React.createElement("div", {
            style: expandedSynopsis === book.id ? S.synopsisExpanded : S.synopsisCollapsed,
            onClick: () => setExpandedSynopsis(expandedSynopsis === book.id ? null : book.id)
          },
            React.createElement("span", { style: S.synopsisText },
              expandedSynopsis === book.id ? book.synopsis : book.synopsis.slice(0, 80) + (book.synopsis.length > 80 ? "..." : "")
            ),
            book.synopsis.length > 80 && React.createElement("span", { style: S.synopsisToggle },
              expandedSynopsis === book.id ? "less" : "more"
            )
          ),
          React.createElement("div", { style: S.moveRow },
            tab !== "reading" && React.createElement("button", { style: S.moveBtn, onClick: () => moveBook(book.id, tab, "reading") }, "Move to Reading"),
            tab !== "want" && React.createElement("button", { style: S.moveBtn, onClick: () => moveBook(book.id, tab, "want") }, "Move to Want"),
            tab !== "finished" && React.createElement("button", { style: { ...S.moveBtn, ...S.moveBtnFinish }, onClick: () => moveBook(book.id, tab, "finished") }, "Mark Finished")
          )
        )
      );

      // ‚îÄ‚îÄ JSX Return ‚îÄ‚îÄ
      return (
        <div style={S.container}>
          {/* Header */}
          <div style={S.header}>
            <h1 style={S.logo}>bookshelf</h1>
            <div style={{ display: "flex", gap: 6, alignItems: "center", position: "relative" }}>
              {syncConnected && <span style={{ fontSize: 10, color: syncStatus === "synced" ? "#16A34A" : syncStatus === "syncing" ? "#D97706" : syncStatus === "error" ? "#DC2626" : "#A8A29E", fontWeight: 500 }}>{syncStatus === "syncing" ? "Syncing..." : syncStatus === "error" ? "Sync error" : ""}</span>}
              <button style={S.headerIcon} onClick={() => setShowSettings(!showSettings)} title="Settings">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
              </button>
              {showSettings && React.createElement("div", { style: S.settingsMenu },
                React.createElement("button", { style: S.settingsItem, onClick: () => { exportLibrary(); setShowSettings(false); } }, "Export backup"),
                React.createElement("button", { style: S.settingsItem, onClick: () => { importLibrary(); setShowSettings(false); } }, "Import backup"),
                React.createElement("button", { style: S.settingsItem, onClick: () => { importSynopses(); setShowSettings(false); } }, "Import synopses"),
                React.createElement("button", { style: S.settingsItem, onClick: () => { importTags(); setShowSettings(false); } }, "Import tags"),
                React.createElement("button", { style: S.settingsItem, onClick: () => { setShowSyncSetup(true); setShowSettings(false); } }, syncConnected ? "Sync settings" : "Set up sync")
              )}
            </div>
          </div>
          {showSettings && React.createElement("div", { style: S.settingsBackdrop, onClick: () => setShowSettings(false) })}

          {/* Search */}
          <div style={S.searchWrap}>
            <input style={{...S.searchInput, paddingLeft: 14}} placeholder="Search your library or check if you've read something‚Ä¶" value={search} onChange={e => setSearch(e.target.value)} />
            {search && <button style={S.clearBtn} onClick={() => setSearch("")}>√ó</button>}
            <button style={S.bulkBtn} onClick={() => setShowBulk(true)} title="Bulk import">Import</button>
          </div>

          {/* Search results */}
          {search.trim() && (
            <div style={S.searchResults}>
              {!urlParsed && (() => {
                const q = search.toLowerCase();
                const finishedMatch = books.finished.filter(b => b.title.toLowerCase().includes(q) || b.author.toLowerCase().includes(q));
                const readingMatch = books.reading.filter(b => b.title.toLowerCase().includes(q) || b.author.toLowerCase().includes(q));
                const wantMatch = books.want.filter(b => b.title.toLowerCase().includes(q) || b.author.toLowerCase().includes(q));
                const hasAny = finishedMatch.length > 0 || readingMatch.length > 0 || wantMatch.length > 0;

                if (finishedMatch.length > 0) return (
                  <div style={S.readCheckBanner}>
                    <div style={S.readCheckIcon}>done</div>
                    <div style={S.readCheckContent}>
                      <div style={S.readCheckTitle}>Yes, you've read {finishedMatch.length === 1 ? "this" : "these"}!</div>
                      <div style={S.readCheckBooks}>{finishedMatch.map(b => <span key={b.id} style={S.readCheckBookName}>{b.title}{b.author ? ` ‚Äî ${b.author}` : ""}</span>)}</div>
                    </div>
                  </div>
                );
                if (readingMatch.length > 0) return (
                  <div style={{...S.readCheckBanner, background: "#FFF8ED", borderColor: "#F0DFB8"}}>
                    <div style={{...S.readCheckIcon, background: "#FFF0D4", color: "#B8860B"}}>!</div>
                    <div style={S.readCheckContent}>
                      <div style={{...S.readCheckTitle, color: "#B8860B"}}>You're reading {readingMatch.length === 1 ? "this" : "these"} now</div>
                      <div style={S.readCheckBooks}>{readingMatch.map(b => <span key={b.id} style={S.readCheckBookName}>{b.title}{b.progress ? ` (${b.progress})` : ""}</span>)}</div>
                    </div>
                  </div>
                );
                if (wantMatch.length > 0) return (
                  <div style={{...S.readCheckBanner, background: "#F0F4FF", borderColor: "#D0DBFF"}}>
                    <div style={{...S.readCheckIcon, background: "#E0E8FF", color: "#4A6FA5"}}>+</div>
                    <div style={S.readCheckContent}>
                      <div style={{...S.readCheckTitle, color: "#4A6FA5"}}>On your Want to Read list</div>
                      <div style={S.readCheckBooks}>{wantMatch.map(b => <span key={b.id} style={S.readCheckBookName}>{b.title}{b.author ? ` ‚Äî ${b.author}` : ""}</span>)}</div>
                    </div>
                  </div>
                );
                if (!hasAny && search.trim().length >= 2) return (
                  <div style={{...S.readCheckBanner, background: "#F5F3F0", borderColor: "#E5E0DA"}}>
                    <div style={{...S.readCheckIcon, background: "#EBE7E2", color: "#A8A29E"}}>‚úó</div>
                    <div style={S.readCheckContent}>
                      <div style={{...S.readCheckTitle, color: "#78716C"}}>Not in your library</div>
                      <div style={{...S.readCheckBooks, color: "#A8A29E"}}>No match for "{search}" in any of your lists</div>
                    </div>
                  </div>
                );
                return null;
              })()}

              {urlParsed && (
                <div style={S.urlCard}>
                  <div style={S.urlCardIcon}>üîó</div>
                  <div style={S.urlCardContent}>
                    <div style={S.urlCardLabel}>Link detected</div>
                    <div style={S.urlCardTitle}>{urlParsed}</div>
                  </div>
                  <button style={S.urlSaveBtn} onClick={() => quickSaveToWant(urlParsed, "")}>+ Save</button>
                </div>
              )}

              {!urlParsed && searchResults.length === 0 ? (
                <div style={S.noResults}>
                  <span style={{ fontSize: 20 }}>üîç</span>
                  <span>No books found matching "{search}"</span>
                  <button style={S.quickAddBtn} onClick={() => quickSaveToWant(search, "")}>
                    Quick save "{search.length > 30 ? search.slice(0, 30) + "‚Ä¶" : search}" to Want to Read
                  </button>
                </div>
              ) : !urlParsed && (
                <>
                  <div style={S.swipeHint}>‚Üê swipe left to save to Want to Read</div>
                  {searchResults.map(book => {
                    const swipeX = swipeStates[book.id] || 0;
                    const isRevealed = swipeX > 70;
                    return (
                      <div key={book.id} style={S.swipeContainer}>
                        <div style={{...S.swipeAction, opacity: Math.min(swipeX / 70, 1), background: isRevealed ? "#D4EDDA" : "#E8F5E9"}}>
                          <span style={{ fontSize: isRevealed ? 18 : 14, transition: "font-size 0.15s" }}>{isRevealed ? "Release to save" : "+"}</span>
                        </div>
                        <div
                          style={{...S.searchResultItem, transform: `translateX(${-swipeX}px)`, transition: swipeX === 0 ? "transform 0.3s ease" : "none"}}
                          onTouchStart={e => handleTouchStart(book.id, e)} onTouchMove={e => handleTouchMove(book.id, e)} onTouchEnd={() => handleTouchEnd(book.id, book)}
                          onMouseDown={e => handleMouseDown(book.id, e)} onMouseMove={e => handleMouseMove(book.id, e)} onMouseUp={() => handleMouseUp(book.id, book)}
                          onMouseLeave={() => { if (touchRef.current[book.id]?.mouseDown) handleMouseUp(book.id, book); }}
                        >
                          <div style={S.searchResultLeft}>
                            <span style={S.formatBadge}>{(book.format || "?")[0]}</span>
                            <div>
                              <div style={S.searchResultTitle}>{book.title}</div>
                              <div style={S.searchResultAuthor}>{book.author}</div>
                            </div>
                          </div>
                          <div style={{
                            ...S.statusBadge,
                            background: getBookStatus(book) === "Finished" ? "#ECFDF5" : getBookStatus(book) === "Currently Reading" ? "#FFF8ED" : "#F0F4FF",
                            color: getBookStatus(book) === "Finished" ? "#166534" : getBookStatus(book) === "Currently Reading" ? "#B8860B" : "#4A6FA5",
                          }}>
                            {getBookStatus(book) === "Finished" ? "" : ""}{getBookStatus(book)}
                          </div>
                        </div>
                      </div>
                    );
                  })}
                </>
              )}
            </div>
          )}

          {/* Nav Bar */}
          <div style={S.navBar}>
            <div style={S.navTabs}>
              {TABS.map(t => (
                <button key={t.id} onClick={() => setTab(t.id)} style={{...S.navTab, ...(tab === t.id ? S.navTabActive : {})}}>
                  {t.label.toUpperCase()}
                </button>
              ))}
            </div>
            <div style={S.navControls}>
              <select style={S.navSelect} value={sortBy} onChange={e => setSortBy(e.target.value)}>
                <option value="date-desc">Newest</option>
                <option value="date-asc">Oldest</option>
                <option value="title-asc">Title A‚ÜíZ</option>
                <option value="title-desc">Title Z‚ÜíA</option>
                <option value="author-asc">Author A‚ÜíZ</option>
                <option value="author-desc">Author Z‚ÜíA</option>
              </select>
              <select style={S.navSelect} value={groupBy} onChange={e => setGroupBy(e.target.value)}>
                <option value="none">No grouping</option>
                <option value="author">By Author</option>
                <option value="format">By Format</option>
                <option value="tag">By Tag</option>
              </select>
            </div>
          </div>
          <div style={S.navCountLine}>{books[tab].length} {books[tab].length === 1 ? "BOOK" : "BOOKS"}</div>

          {/* Book list */}
          <div style={S.bookList}>
            {sortedBooks.length === 0 && !search.trim() ? (
              <div style={S.empty}>
                <div style={S.emptyIcon}>{tab === "reading" ? "" : tab === "want" ? "" : ""}</div>
                <div style={S.emptyTitle}>{tab === "reading" ? "Nothing on your plate" : tab === "want" ? "Your wish list is empty" : "No books finished yet"}</div>
                <div style={S.emptyHint}>Tap the + button to add your first book</div>
              </div>
            ) : groupedBooks ? (
              groupedBooks.map(([groupName, groupItems]) => (
                <div key={groupName}>
                  <div style={S.groupHeader}>
                    {groupBy === "format" && FORMAT_ICONS[groupName] ? FORMAT_ICONS[groupName] + " " : ""}{groupName}
                    <span style={S.groupCount}>{groupItems.length}</span>
                  </div>
                  {groupItems.map((book, i) => (
                    <div key={book.id} style={{...S.bookCard, animationDelay: `${i * 0.05}s`}}>{renderBookCard(book)}</div>
                  ))}
                </div>
              ))
            ) : (
              sortedBooks.map((book, i) => (
                <div key={book.id} style={{...S.bookCard, animationDelay: `${i * 0.05}s`}}>{renderBookCard(book)}</div>
              ))
            )}
          </div>

          {/* FAB */}
          {!showAdd && <button style={S.fab} onClick={() => setShowAdd(true)}>+</button>}

          {/* Add/Edit Modal */}
          {showAdd && (
            <div style={S.overlay} onClick={resetForm}>
              <div style={S.modal} onClick={e => e.stopPropagation()}>
                <div style={S.modalHeader}>
                  <h2 style={S.modalTitle}>{editingId ? "Edit Book" : "Add a Book"}</h2>
                  <button style={S.modalClose} onClick={resetForm}>√ó</button>
                </div>
                <div style={S.formGroup}>
                  <label style={S.label}>Title</label>
                  <input ref={inputRef} style={S.input} placeholder="e.g. Project Hail Mary" value={title} onChange={e => setTitle(e.target.value)} onKeyDown={e => e.key === "Enter" && addBook()} />
                </div>
                <div style={S.formGroup}>
                  <label style={S.label}>Author</label>
                  <input style={S.input} placeholder="e.g. Andy Weir" value={author} onChange={e => setAuthor(e.target.value)} onKeyDown={e => e.key === "Enter" && addBook()} />
                </div>
                <div style={S.formGroup}>
                  <label style={S.label}>Cover Image URL (optional)</label>
                  <input style={S.input} placeholder="Paste image link‚Ä¶" value={coverUrl} onChange={e => setCoverUrl(e.target.value)} />
                  {coverUrl.trim() && <img src={coverUrl} style={S.coverPreview} alt="Cover preview" onError={e => { e.target.style.display = "none"; }} />}
                </div>
                <div style={S.formGroup}>
                  <label style={S.label}>Synopsis (optional)</label>
                  <textarea style={{...S.input, minHeight: 70, resize: "vertical", lineHeight: 1.5, fontFamily: "'Karla', sans-serif", fontSize: 13}} placeholder="Short description of the book..." value={synopsis} onChange={e => setSynopsis(e.target.value)} />
                </div>
                <div style={S.formGroup}>
                  <label style={S.label}>{tab === "want" ? "Date Saved" : "Date Started"}</label>
                  <input type="date" style={S.dateInput} value={dateStarted} onChange={e => setDateStarted(e.target.value)} />
                </div>
                {(tab !== "want" || editingId) && (<>
                <div style={S.formRow}>
                  <div style={{ flex: 1 }}>
                    <label style={S.label}>Format</label>
                    <div style={S.segmented}>
                      {FORMATS.map(f => <button key={f} style={{...S.segBtn, ...(format === f ? S.segBtnActive : {})}} onClick={() => setFormat(f)}>{f}</button>)}
                    </div>
                  </div>
                </div>
                <div style={S.formRow}>
                  <div style={{ flex: 1 }}>
                    <label style={S.label}>Platform</label>
                    <div style={S.segmented}>
                      {PLATFORMS[format].map(p => (
                        <button key={p} style={{...S.segBtn, ...(platform === p ? {...S.segBtnActive, background: PLATFORM_COLORS[p] + "20", color: PLATFORM_COLORS[p], borderColor: PLATFORM_COLORS[p] + "50"} : {})}} onClick={() => setPlatform(p)}>{p}</button>
                      ))}
                    </div>
                  </div>
                </div>
                </>)}
                <div style={S.formGroup}>
                  <label style={S.label}>Tags</label>
                  <div style={S.tagSelector}>
                    {GENRES.map(g => (
                      <button key={g} style={{...S.tagChip, ...(tags.includes(g) ? S.tagChipActive : {})}}
                        onClick={() => setTags(prev => prev.includes(g) ? prev.filter(t => t !== g) : [...prev, g])}>{g}</button>
                    ))}
                    {customTags.map(g => (
                      <button key={g} style={{...S.tagChip, ...(tags.includes(g) ? S.tagChipCustomActive : S.tagChipCustom)}}
                        onClick={() => setTags(prev => prev.includes(g) ? prev.filter(t => t !== g) : [...prev, g])}>{g}</button>
                    ))}
                  </div>
                  <div style={S.customTagRow}>
                    <input style={{...S.input, flex: 1, marginBottom: 0}} placeholder="Add custom tag‚Ä¶" value={customTagInput}
                      onChange={e => setCustomTagInput(e.target.value)}
                      onKeyDown={e => {
                        if (e.key === "Enter" && customTagInput.trim()) {
                          const t = customTagInput.trim();
                          if (!GENRES.includes(t) && !customTags.includes(t)) setCustomTags(prev => [...prev, t]);
                          if (!tags.includes(t)) setTags(prev => [...prev, t]);
                          setCustomTagInput("");
                        }
                      }} />
                    <button style={S.customTagAddBtn} onClick={() => {
                      const t = customTagInput.trim();
                      if (!t) return;
                      if (!GENRES.includes(t) && !customTags.includes(t)) setCustomTags(prev => [...prev, t]);
                      if (!tags.includes(t)) setTags(prev => [...prev, t]);
                      setCustomTagInput("");
                    }}>+</button>
                  </div>
                </div>
                <div style={S.formGroup}>
                  <label style={S.label}>Add to</label>
                  <div style={S.segmented}>
                    {TABS.map(t => <button key={t.id} style={{...S.segBtn, ...(tab === t.id ? S.segBtnActive : {})}} onClick={() => !editingId && setTab(t.id)}>{t.label}</button>)}
                  </div>
                </div>
                <button style={{...S.submitBtn, opacity: title.trim() ? 1 : 0.4, cursor: title.trim() ? "pointer" : "not-allowed"}} onClick={addBook} disabled={!title.trim()}>
                  {editingId ? "Save Changes" : `Add to ${TABS.find(t => t.id === tab)?.label}`}
                </button>
              </div>
            </div>
          )}

          {/* Toast */}
          {toast && (
            <div style={{...S.toast, background: toast.type === "success" ? "#ECFDF5" : "#FFF8ED", borderColor: toast.type === "success" ? "#BBF7D0" : "#F0DFB8", color: toast.type === "success" ? "#166534" : "#B8860B"}}>
              {toast.text}
            </div>
          )}

          {/* Bulk Import Modal */}
          {showBulk && (
            <div style={S.overlay} onClick={() => { setShowBulk(false); setBulkText(""); setBulkPreview([]); }}>
              <div style={S.modal} onClick={e => e.stopPropagation()}>
                <div style={S.modalHeader}>
                  <h2 style={S.modalTitle}>Bulk Import</h2>
                  <button style={S.modalClose} onClick={() => { setShowBulk(false); setBulkText(""); setBulkPreview([]); }}>√ó</button>
                </div>
                <div style={S.bulkHint}>Paste your book list below. Supports Kindle's "Manage Content" format and simple lists:</div>
                <div style={S.bulkExamples}>
                  <div style={S.bulkExampleLabel}>Kindle paste:</div>
                  <div style={S.bulkExampleLine}>Then She Was Gone: A Novel</div>
                  <div style={S.bulkExampleLine}>Lisa Jewell</div>
                  <div style={S.bulkExampleLine}>Acquired on January 18, 2026</div>
                  <div style={{ height: 8 }} />
                  <div style={S.bulkExampleLabel}>Simple list:</div>
                  <div style={S.bulkExampleLine}>Project Hail Mary by Andy Weir</div>
                  <div style={S.bulkExampleLine}>Dune - Frank Herbert</div>
                </div>
                <div style={S.formGroup}>
                  <label style={S.label}>Book List</label>
                  <textarea ref={bulkRef} style={S.bulkTextarea} placeholder={"Paste your books here, one per line...\ne.g. Title by Author"} value={bulkText} onChange={e => setBulkText(e.target.value)} rows={8} />
                </div>
                {bulkPreview.length > 0 && (
                  <div style={S.formGroup}>
                    <label style={S.label}>Preview ({bulkPreview.length} book{bulkPreview.length !== 1 ? "s" : ""} detected)</label>
                    <div style={S.bulkPreviewList}>
                      {bulkPreview.map((b, i) => (
                        <div key={i} style={S.bulkPreviewItem}>
                          <div style={{ flex: 1, minWidth: 0 }}>
                            <span style={S.bulkPreviewTitle}>{b.title}</span>
                            {b.author && <span style={S.bulkPreviewAuthor}> ‚Äî {b.author}</span>}
                          </div>
                          {b.dateStarted && <span style={S.bulkPreviewDate}>{new Date(b.dateStarted + "T00:00:00").toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" })}</span>}
                        </div>
                      ))}
                    </div>
                  </div>
                )}
                {bulkTab !== "want" && (<>
                <div style={S.formRow}>
                  <div style={{ flex: 1 }}>
                    <label style={S.label}>Format</label>
                    <div style={S.segmented}>
                      {FORMATS.map(f => <button key={f} style={{...S.segBtn, ...(bulkFormat === f ? S.segBtnActive : {})}} onClick={() => setBulkFormat(f)}>{f}</button>)}
                    </div>
                  </div>
                </div>
                <div style={S.formRow}>
                  <div style={{ flex: 1 }}>
                    <label style={S.label}>Platform</label>
                    <div style={S.segmented}>
                      {PLATFORMS[bulkFormat].map(p => (
                        <button key={p} style={{...S.segBtn, ...(bulkPlatform === p ? {...S.segBtnActive, background: PLATFORM_COLORS[p] + "20", color: PLATFORM_COLORS[p], borderColor: PLATFORM_COLORS[p] + "50"} : {})}} onClick={() => setBulkPlatform(p)}>{p}</button>
                      ))}
                    </div>
                  </div>
                </div>
                </>)}
                <div style={S.formGroup}>
                  <label style={S.label}>Add to</label>
                  <div style={S.segmented}>
                    {TABS.map(t => <button key={t.id} style={{...S.segBtn, ...(bulkTab === t.id ? S.segBtnActive : {})}} onClick={() => setBulkTab(t.id)}>{t.label}</button>)}
                  </div>
                </div>
                <button style={{...S.submitBtn, opacity: bulkPreview.length > 0 ? 1 : 0.4, cursor: bulkPreview.length > 0 ? "pointer" : "not-allowed"}} onClick={submitBulk} disabled={bulkPreview.length === 0}>
                  Import {bulkPreview.length} Book{bulkPreview.length !== 1 ? "s" : ""}
                </button>
              </div>
            </div>
          )}

          {/* Sync Setup Modal */}
          {showSyncSetup && (() => {
            const handleConnect = async () => {
              if (!syncTokenInput.trim()) { setSyncError("Please enter a token."); return; }
              setSyncWorking(true);
              setSyncError("");
              if (syncGistIdInput.trim()) {
                saveGistConfig(syncTokenInput.trim(), syncGistIdInput.trim());
                const data = await gistFetch();
                if (data) {
                  if (data.books && data.books.reading) setBooks(data.books);
                  if (data.customTags) setCustomTags(data.customTags);
                  setSyncConnected(true);
                  setSyncStatus("synced");
                  setSyncStep("connected");
                  showToast("Connected and synced from Gist");
                } else {
                  clearGistConfig();
                  setSyncError("Could not access that Gist. Check your token and Gist ID.");
                }
              } else {
                const newId = await gistCreate(syncTokenInput.trim());
                if (newId) {
                  saveGistConfig(syncTokenInput.trim(), newId);
                  await gistPush({ books, customTags, lastUpdated: new Date().toISOString() });
                  setSyncConnected(true);
                  setSyncStatus("synced");
                  setSyncStep("connected");
                  showToast("Gist created and library synced");
                } else {
                  setSyncError("Could not create Gist. Check that your token has 'gist' scope.");
                }
              }
              setSyncWorking(false);
            };

            const handleDisconnect = () => {
              clearGistConfig();
              setSyncConnected(false);
              setSyncStatus("idle");
              setSyncStep("start");
              setSyncTokenInput("");
              setSyncGistIdInput("");
              showToast("Sync disconnected");
            };

            const handleForceSync = async () => {
              setSyncWorking(true);
              setSyncStatus("syncing");
              const ok = await gistPush({ books, customTags, lastUpdated: new Date().toISOString() });
              setSyncStatus(ok ? "synced" : "error");
              showToast(ok ? "Library pushed to Gist" : "Sync failed");
              setSyncWorking(false);
            };

            const handleForcePull = async () => {
              setSyncWorking(true);
              setSyncStatus("syncing");
              const data = await gistFetch();
              if (data && data.books) {
                setBooks(data.books);
                if (data.customTags) setCustomTags(data.customTags);
                setSyncStatus("synced");
                showToast("Library pulled from Gist");
              } else {
                setSyncStatus("error");
                showToast("Pull failed");
              }
              setSyncWorking(false);
            };

            const currentGistId = getGistConfig().gistId;

            return React.createElement("div", { style: S.overlay, onClick: () => setShowSyncSetup(false) },
              React.createElement("div", { style: {...S.modal, maxWidth: 420}, onClick: e => e.stopPropagation() },
                React.createElement("div", { style: S.modalHeader },
                  React.createElement("span", { style: S.modalTitle }, "Sync Settings"),
                  React.createElement("button", { style: S.closeBtn, onClick: () => setShowSyncSetup(false) }, "x")
                ),
                syncStep === "connected" ? React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 12 } },
                  React.createElement("div", { style: { fontSize: 13, color: "#57534E", lineHeight: 1.5 } },
                    "Connected to Gist. Your library auto-syncs across devices."
                  ),
                  React.createElement("div", { style: { fontSize: 11, color: "#A8A29E", wordBreak: "break-all" } }, "Gist ID: " + currentGistId),
                  React.createElement("div", { style: { display: "flex", gap: 8, marginTop: 4 } },
                    React.createElement("button", { style: {...S.moveBtn, flex: 1, opacity: syncWorking ? 0.5 : 1}, onClick: handleForceSync, disabled: syncWorking }, "Push to Gist"),
                    React.createElement("button", { style: {...S.moveBtn, flex: 1, opacity: syncWorking ? 0.5 : 1}, onClick: handleForcePull, disabled: syncWorking }, "Pull from Gist")
                  ),
                  React.createElement("button", { style: {...S.moveBtn, color: "#DC2626", borderColor: "#FECACA", marginTop: 4}, onClick: handleDisconnect }, "Disconnect")
                ) : React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 12 } },
                  React.createElement("div", { style: { fontSize: 13, color: "#57534E", lineHeight: 1.6 } },
                    "Sync your library across devices using a private GitHub Gist."
                  ),
                  React.createElement("div", { style: { fontSize: 12, color: "#78716C", lineHeight: 1.5, background: "#F7F5F0", borderRadius: 8, padding: "10px 12px" } },
                    "1. Go to github.com/settings/tokens",
                    React.createElement("br"),
                    '2. Generate a token with "gist" scope',
                    React.createElement("br"),
                    "3. Paste it below"
                  ),
                  React.createElement("input", { style: S.input, placeholder: "GitHub Personal Access Token", value: syncTokenInput, onChange: e => setSyncTokenInput(e.target.value), type: "password" }),
                  React.createElement("input", { style: S.input, placeholder: "Existing Gist ID (leave blank to create new)", value: syncGistIdInput, onChange: e => setSyncGistIdInput(e.target.value) }),
                  syncError && React.createElement("div", { style: { fontSize: 12, color: "#DC2626" } }, syncError),
                  React.createElement("button", { style: {...S.submitBtn, opacity: syncWorking ? 0.5 : 1}, onClick: handleConnect, disabled: syncWorking }, syncWorking ? "Connecting..." : "Connect")
                )
              )
            );
          })()}
        </div>
      );
    }

    // ‚îÄ‚îÄ Styles ‚îÄ‚îÄ
    const S = {
      container: { fontFamily: "'Karla', sans-serif", background: "#F7F5F0", minHeight: "100vh", color: "#1A1917", padding: "calc(28px + env(safe-area-inset-top)) 24px calc(100px + env(safe-area-inset-bottom))", maxWidth: 800, margin: "0 auto" },
      header: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 16, paddingBottom: 0 },
      headerLeft: { display: "flex", flexDirection: "column", gap: 2 },
      logo: { fontFamily: "'Cormorant Garamond', serif", fontSize: 24, fontWeight: 400, color: "#1A1917", letterSpacing: "-0.5px", lineHeight: 1 },
      headerIcon: { background: "none", border: "none", color: "#1A1917", cursor: "pointer", padding: 4, borderRadius: 8, display: "flex", alignItems: "center", justifyContent: "center", transition: "color 0.15s" },
      dataBtn: { background: "none", border: "1px solid #DDD8D0", borderRadius: 6, color: "#A8A29E", fontSize: 11, fontFamily: "'Karla', sans-serif", fontWeight: 500, cursor: "pointer", padding: "3px 8px", transition: "all 0.15s", whiteSpace: "nowrap" },
      settingsMenu: { position: "absolute", top: "calc(100% + 8px)", right: 0, background: "#FFFEF9", border: "1px solid rgba(0,0,0,0.06)", borderRadius: 12, padding: 6, boxShadow: "0 4px 20px rgba(0,0,0,0.08)", zIndex: 100, minWidth: 170, animation: "fadeIn 0.15s ease" },
      settingsItem: { display: "block", width: "100%", background: "none", border: "none", padding: "10px 14px", fontSize: 13, fontFamily: "'Karla', sans-serif", color: "#1A1917", cursor: "pointer", textAlign: "left", borderRadius: 8, transition: "background 0.15s" },
      settingsBackdrop: { position: "fixed", top: 0, left: 0, right: 0, bottom: 0, zIndex: 99 },
      searchWrap: { position: "relative", marginBottom: 16, display: "flex", gap: 8, alignItems: "center" },
      searchIcon: { position: "absolute", left: 14, top: "50%", transform: "translateY(-50%)", fontSize: 16, color: "#A8A29E", pointerEvents: "none" },
      searchInput: { flex: 1, padding: "11px 40px 11px 40px", background: "#FFFEF9", border: "1px solid #DDD8D0", borderRadius: 10, color: "#1C1917", fontSize: 14, fontFamily: "'Karla', sans-serif", transition: "border-color 0.2s" },
      bulkBtn: { padding: "11px 14px", background: "#FFFEF9", border: "1px solid #DDD8D0", borderRadius: 10, color: "#78716C", fontSize: 12, fontFamily: "'Karla', sans-serif", fontWeight: 500, cursor: "pointer", whiteSpace: "nowrap", transition: "all 0.15s", letterSpacing: "0.02em" },
      clearBtn: { position: "absolute", right: 96, top: "50%", transform: "translateY(-50%)", background: "none", border: "none", color: "#A8A29E", fontSize: 18, cursor: "pointer", padding: "4px 8px" },
      searchResults: { background: "#FFFEF9", border: "1px solid #DDD8D0", borderRadius: 12, padding: 6, marginBottom: 16, animation: "fadeIn 0.2s ease", boxShadow: "0 1px 3px rgba(0,0,0,0.04)" },
      searchResultItem: { display: "flex", justifyContent: "space-between", alignItems: "center", padding: "10px 12px", borderRadius: 8, transition: "background 0.15s", cursor: "default", background: "#FFFEF9", position: "relative", zIndex: 1, userSelect: "none" },
      searchResultLeft: { display: "flex", gap: 10, alignItems: "center" },
      searchResultTitle: { fontSize: 14, fontWeight: 500, color: "#1C1917" },
      searchResultAuthor: { fontSize: 12, color: "#A8A29E", marginTop: 1 },
      formatBadge: { fontSize: 16, width: 32, height: 32, display: "flex", alignItems: "center", justifyContent: "center", background: "#F5F3F0", borderRadius: 8 },
      statusBadge: { fontSize: 10, fontWeight: 600, padding: "4px 9px", borderRadius: 20, letterSpacing: "0.04em", textTransform: "uppercase", whiteSpace: "nowrap" },
      noResults: { display: "flex", flexDirection: "column", alignItems: "center", gap: 6, padding: "20px 16px", color: "#78716C", fontSize: 14 },
      navBar: { display: "flex", justifyContent: "space-between", alignItems: "center", borderBottom: "1px solid rgba(0,0,0,0.06)", marginBottom: 16, gap: 12, padding: "4px 0 8px" },
      navTabs: { display: "flex", gap: 0 },
      navTab: { background: "none", border: "none", borderBottom: "2px solid transparent", padding: "8px 14px 8px 0", color: "#B5AFA7", fontSize: 10, fontFamily: "'IBM Plex Mono', monospace", fontWeight: 400, cursor: "pointer", letterSpacing: "1.5px", transition: "all 0.2s", display: "flex", alignItems: "center", gap: 5, whiteSpace: "nowrap", textTransform: "uppercase" },
      navTabActive: { color: "#1A1917", borderBottomColor: "#1A1917" },
      navCountLine: { fontFamily: "'IBM Plex Mono', monospace", fontSize: 9, letterSpacing: "2px", color: "#A09B93", padding: "8px 0 12px" },
      navControls: { display: "flex", gap: 6, alignItems: "center", flexShrink: 0 },
      navSelect: { background: "transparent", border: "1px solid #DDD8D0", borderRadius: 20, padding: "5px 10px", fontSize: 11, fontFamily: "'Karla', sans-serif", color: "#9A958D", cursor: "pointer", fontWeight: 400 },
      groupHeader: { fontSize: 12, fontWeight: 600, color: "#78716C", textTransform: "uppercase", letterSpacing: "0.06em", padding: "16px 0 6px", display: "flex", alignItems: "center", gap: 8 },
      groupCount: { fontSize: 10, fontWeight: 600, background: "#F0EDE8", color: "#A8A29E", padding: "2px 6px", borderRadius: 8 },
      bookList: { display: "flex", flexDirection: "column", gap: 8 },
      bookCard: { background: "#FFFEF9", border: "1px solid rgba(0,0,0,0.06)", borderRadius: 12, padding: "16px 18px", animation: "slideUp 0.3s ease both" },
      bookTop: { display: "flex", justifyContent: "space-between", alignItems: "flex-start", marginBottom: 10 },
      bookInfo: { flex: 1, paddingRight: 12 },
      bookTitle: { fontFamily: "'Cormorant Garamond', serif", fontSize: 16, fontWeight: 400, color: "#1C1917", lineHeight: 1.35 },
      bookAuthor: { fontSize: 13, color: "#A8A29E", fontStyle: "italic" },
      authorRow: { display: "flex", alignItems: "center", gap: 8, marginTop: 2 },
      platformTagInline: { fontSize: 10, fontWeight: 500, padding: "1px 7px", borderRadius: 10, border: "1px solid", letterSpacing: "0.02em", whiteSpace: "nowrap" },
      bookActions: { display: "flex", gap: 2, alignItems: "flex-start", paddingTop: 2 },
      iconBtn: { background: "none", border: "none", color: "#A8A29E", fontSize: 15, cursor: "pointer", padding: "4px 6px", borderRadius: 6, transition: "color 0.15s" },
      confirmRow: { display: "flex", gap: 2, fontSize: 12 },
      bookMeta: { display: "flex", gap: 6, flexWrap: "wrap", alignItems: "center", marginTop: 6 },
      platformTag: { fontSize: 11, fontWeight: 500, padding: "3px 9px", borderRadius: 16, border: "1px solid", letterSpacing: "0.02em" },
      progressTag: { fontSize: 11, color: "#78716C", background: "#F5F3F0", padding: "3px 9px", borderRadius: 16, fontWeight: 500 },
      dateTag: { fontSize: 11, color: "#A8A29E", marginLeft: "auto" },
      moveRow: { display: "flex", gap: 4, paddingTop: 10, borderTop: "1px solid #F0EDE8" },
      moveBtn: { flex: 1, padding: "6px 0", background: "transparent", border: "1px solid #DDD8D0", borderRadius: 7, color: "#78716C", fontSize: 11, fontFamily: "'Karla', sans-serif", fontWeight: 500, cursor: "pointer", transition: "all 0.15s" },
      moveBtnFinish: { borderColor: "#BBF7D0", color: "#166534", background: "#F0FDF4" },
      empty: { display: "flex", flexDirection: "column", alignItems: "center", gap: 6, padding: "56px 20px", color: "#A8A29E" },
      emptyIcon: { fontSize: 36, marginBottom: 6 },
      emptyTitle: { fontFamily: "'Cormorant Garamond', serif", fontSize: 17, color: "#78716C" },
      emptyHint: { fontSize: 13, color: "#A8A29E" },
      fab: { position: "fixed", bottom: 28, right: 24, width: 52, height: 52, borderRadius: "50%", background: "#1A1917", border: "none", color: "#F7F5F0", fontSize: 26, fontWeight: 300, cursor: "pointer", boxShadow: "0 2px 12px rgba(26,25,23,0.25)", display: "flex", alignItems: "center", justifyContent: "center", transition: "transform 0.2s, box-shadow 0.2s", zIndex: 100 },
      overlay: { position: "fixed", inset: 0, background: "rgba(0,0,0,0.3)", backdropFilter: "blur(10px)", display: "flex", alignItems: "flex-end", justifyContent: "center", zIndex: 200, animation: "fadeIn 0.2s ease" },
      modal: { background: "#FFFEF9", border: "1px solid #DDD8D0", borderRadius: "20px 20px 0 0", padding: "22px 22px 30px", width: "100%", maxWidth: 560, maxHeight: "85vh", overflow: "auto", animation: "slideUp 0.3s ease", boxShadow: "0 -4px 24px rgba(0,0,0,0.08)" },
      modalHeader: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 22 },
      modalTitle: { fontFamily: "'Cormorant Garamond', serif", fontSize: 20, fontWeight: 400, color: "#1C1917" },
      modalClose: { background: "none", border: "none", color: "#A8A29E", fontSize: 22, cursor: "pointer", padding: "4px 8px" },
      formGroup: { marginBottom: 16 },
      formRow: { display: "flex", gap: 10, marginBottom: 16 },
      label: { display: "block", fontSize: 9, fontWeight: 400, color: "#A09B93", textTransform: "uppercase", letterSpacing: "2px", marginBottom: 6, fontFamily: "'IBM Plex Mono', monospace" },
      input: { width: "100%", padding: "10px 12px", background: "#F7F5F0", border: "1px solid #DDD8D0", borderRadius: 8, color: "#1C1917", fontSize: 14, fontFamily: "'Karla', sans-serif" },
      dateInput: { width: "100%", padding: "10px 12px", background: "#F7F5F0", border: "1px solid #DDD8D0", borderRadius: 8, color: "#1C1917", fontSize: 14, fontFamily: "'Karla', sans-serif", colorScheme: "light" },
      segmented: { display: "flex", gap: 4, flexWrap: "wrap" },
      segBtn: { flex: 1, padding: "8px 10px", background: "#F7F5F0", border: "1px solid #DDD8D0", borderRadius: 7, color: "#A8A29E", fontSize: 12, fontFamily: "'Karla', sans-serif", fontWeight: 500, cursor: "pointer", transition: "all 0.15s", whiteSpace: "nowrap", minWidth: "fit-content" },
      segBtnActive: { background: "#FFFEF9", color: "#1C1917", borderColor: "#D4CFC8", boxShadow: "0 1px 2px rgba(0,0,0,0.04)" },
      submitBtn: { width: "100%", padding: "12px", background: "#1A1917", border: "none", borderRadius: 6, color: "#F7F5F0", fontSize: 12, fontFamily: "'IBM Plex Mono', monospace", fontWeight: 400, cursor: "pointer", marginTop: 6, letterSpacing: "1px", textTransform: "uppercase", transition: "opacity 0.2s" },
      bulkHint: { fontSize: 13, color: "#78716C", lineHeight: 1.5, marginBottom: 10 },
      bulkExamples: { background: "#F7F5F0", border: "1px solid #DDD8D0", borderRadius: 8, padding: "10px 14px", marginBottom: 18, display: "flex", flexDirection: "column", gap: 3 },
      bulkExampleLine: { fontSize: 12, color: "#A8A29E", fontFamily: "monospace", lineHeight: 1.5 },
      bulkExampleLabel: { fontSize: 10, color: "#A8A29E", textTransform: "uppercase", letterSpacing: "0.08em", fontWeight: 600, fontFamily: "'Karla', sans-serif", marginBottom: 2 },
      bulkTextarea: { width: "100%", padding: "10px 12px", background: "#F7F5F0", border: "1px solid #DDD8D0", borderRadius: 8, color: "#1C1917", fontSize: 14, fontFamily: "'Karla', sans-serif", resize: "vertical", minHeight: 130, lineHeight: 1.5 },
      bulkPreviewList: { background: "#F7F5F0", border: "1px solid #DDD8D0", borderRadius: 8, padding: 6, maxHeight: 160, overflow: "auto" },
      bulkPreviewItem: { display: "flex", justifyContent: "space-between", alignItems: "center", padding: "7px 10px", borderRadius: 6, gap: 8 },
      bulkPreviewTitle: { fontSize: 13, color: "#1C1917", fontWeight: 500 },
      bulkPreviewAuthor: { fontSize: 12, color: "#A8A29E", fontStyle: "italic", textAlign: "right", flexShrink: 0 },
      bulkPreviewDate: { fontSize: 11, color: "#A8A29E", whiteSpace: "nowrap", flexShrink: 0, marginLeft: 8 },
      swipeContainer: { position: "relative", overflow: "hidden", borderRadius: 8 },
      swipeAction: { position: "absolute", right: 0, top: 0, bottom: 0, width: 120, display: "flex", alignItems: "center", justifyContent: "center", borderRadius: 8, color: "#166534", fontWeight: 500, fontSize: 12, transition: "background 0.15s" },
      swipeHint: { fontSize: 11, color: "#A8A29E", textAlign: "center", padding: "5px 0 3px", letterSpacing: "0.03em" },
      urlCard: { display: "flex", alignItems: "center", gap: 10, padding: "12px 14px", background: "#F7F5F0", borderRadius: 10, border: "1px solid #DDD8D0", margin: 6 },
      urlCardIcon: { fontSize: 20, width: 36, height: 36, display: "flex", alignItems: "center", justifyContent: "center", background: "#FFFEF9", borderRadius: 8, flexShrink: 0 },
      urlCardContent: { flex: 1, minWidth: 0 },
      urlCardLabel: { fontSize: 10, color: "#A8A29E", textTransform: "uppercase", letterSpacing: "0.08em", fontWeight: 600, marginBottom: 2 },
      urlCardTitle: { fontSize: 14, color: "#1C1917", fontWeight: 500, overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" },
      urlSaveBtn: { padding: "7px 14px", background: "#C2785C", border: "none", borderRadius: 8, color: "#FFFFFF", fontSize: 13, fontFamily: "'Karla', sans-serif", fontWeight: 600, cursor: "pointer", whiteSpace: "nowrap", flexShrink: 0 },
      quickAddBtn: { marginTop: 10, padding: "9px 16px", background: "#F0FDF4", border: "1px solid #BBF7D0", borderRadius: 8, color: "#166534", fontSize: 13, fontFamily: "'Karla', sans-serif", fontWeight: 500, cursor: "pointer", transition: "all 0.15s", maxWidth: "100%", overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" },
      toast: { position: "fixed", bottom: 100, left: "50%", transform: "translateX(-50%)", padding: "10px 18px", borderRadius: 10, border: "1px solid", fontSize: 13, fontWeight: 500, fontFamily: "'Karla', sans-serif", zIndex: 300, animation: "slideUp 0.3s ease", boxShadow: "0 4px 16px rgba(0,0,0,0.08)", whiteSpace: "nowrap", maxWidth: "90vw", overflow: "hidden", textOverflow: "ellipsis" },
      readCheckBanner: { display: "flex", alignItems: "flex-start", gap: 12, padding: "14px 16px", margin: "6px 6px 4px", background: "#ECFDF5", border: "1px solid #BBF7D0", borderRadius: 10, animation: "slideUp 0.25s ease" },
      readCheckIcon: { width: 36, height: 36, borderRadius: 18, display: "flex", alignItems: "center", justifyContent: "center", fontSize: 16, fontWeight: 700, background: "#D1FAE5", color: "#166534", flexShrink: 0 },
      readCheckContent: { flex: 1, minWidth: 0 },
      readCheckTitle: { fontSize: 14, fontWeight: 600, color: "#166534", fontFamily: "'Karla', sans-serif", marginBottom: 3 },
      readCheckBooks: { fontSize: 13, color: "#78716C", lineHeight: 1.5, display: "flex", flexDirection: "column", gap: 2 },
      readCheckBookName: { fontFamily: "'Cormorant Garamond', serif", fontStyle: "italic", fontSize: 13, color: "#57534E" },
      tagSelector: { display: "flex", flexWrap: "wrap", gap: 4, marginBottom: 8 },
      tagChip: { padding: "5px 10px", background: "#F7F5F0", border: "1px solid #DDD8D0", borderRadius: 14, color: "#78716C", fontSize: 11, fontFamily: "'Karla', sans-serif", fontWeight: 500, cursor: "pointer", transition: "all 0.15s", whiteSpace: "nowrap" },
      tagChipActive: { background: "#C2785C18", color: "#C2785C", borderColor: "#C2785C40" },
      tagChipCustom: { background: "#F0F4FF", borderColor: "#D0DBFF", color: "#4A6FA5" },
      tagChipCustomActive: { background: "#4A6FA520", color: "#4A6FA5", borderColor: "#4A6FA560" },
      customTagRow: { display: "flex", gap: 6, alignItems: "center", marginTop: 6 },
      customTagAddBtn: { width: 34, height: 34, borderRadius: 8, background: "#C2785C", border: "none", color: "#FFFFFF", fontSize: 18, fontWeight: 300, cursor: "pointer", display: "flex", alignItems: "center", justifyContent: "center", flexShrink: 0 },
      genreTag: { fontSize: 10, fontWeight: 400, padding: "2px 8px", borderRadius: 12, background: "#8C857A12", color: "#8C857A", border: "1px solid #8C857A25", fontFamily: "'IBM Plex Mono', monospace", letterSpacing: "0.5px" },
      coverImg: { width: 56, height: 84, objectFit: "cover", borderRadius: 6, flexShrink: 0, marginRight: 14, boxShadow: "0 2px 8px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.06)" },
      coverPreview: { width: 60, height: 90, objectFit: "cover", borderRadius: 6, marginTop: 8, boxShadow: "0 1px 4px rgba(0,0,0,0.1)" },
      synopsisCollapsed: { padding: "6px 0 0", cursor: "pointer", display: "flex", alignItems: "baseline", gap: 4 },
      synopsisExpanded: { padding: "8px 10px", marginTop: 6, cursor: "pointer", background: "#F7F5F0", borderRadius: 8, display: "flex", flexDirection: "column", gap: 4 },
      synopsisText: { fontSize: 11, color: "#A8A29E", lineHeight: 1.45 },
      synopsisToggle: { fontSize: 10, color: "#8C857A", fontWeight: 500, flexShrink: 0, letterSpacing: "0.02em" },
    };

    ReactDOM.createRoot(document.getElementById("root")).render(React.createElement(BookTracker));
  </script>
</body>
</html>
